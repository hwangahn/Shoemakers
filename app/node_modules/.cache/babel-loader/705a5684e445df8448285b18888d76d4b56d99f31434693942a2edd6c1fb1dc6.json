{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar http = require('http'),\n  IncomingMessageExt = require('../http/request'),\n  AuthenticationError = require('../errors/authenticationerror');\n\n/**\n * Authenticates requests.\n *\n * Applies the `name`ed strategy (or strategies) to the incoming request, in\n * order to authenticate the request.  If authentication is successful, the user\n * will be logged in and populated at `req.user` and a session will be\n * established by default.  If authentication fails, an unauthorized response\n * will be sent.\n *\n * Options:\n *   - `session`          Save login state in session, defaults to _true_\n *   - `successRedirect`  After successful login, redirect to given URL\n *   - `successMessage`   True to store success message in\n *                        req.session.messages, or a string to use as override\n *                        message for success.\n *   - `successFlash`     True to flash success messages or a string to use as a flash\n *                        message for success (overrides any from the strategy itself).\n *   - `failureRedirect`  After failed login, redirect to given URL\n *   - `failureMessage`   True to store failure message in\n *                        req.session.messages, or a string to use as override\n *                        message for failure.\n *   - `failureFlash`     True to flash failure messages or a string to use as a flash\n *                        message for failures (overrides any from the strategy itself).\n *   - `assignProperty`   Assign the object provided by the verify callback to given property\n *\n * An optional `callback` can be supplied to allow the application to override\n * the default manner in which authentication attempts are handled.  The\n * callback has the following signature, where `user` will be set to the\n * authenticated user on a successful authentication attempt, or `false`\n * otherwise.  An optional `info` argument will be passed, containing additional\n * details provided by the strategy's verify callback - this could be information about\n * a successful authentication or a challenge message for a failed authentication.\n * An optional `status` argument will be passed when authentication fails - this could\n * be a HTTP response code for a remote authentication failure or similar.\n *\n *     app.get('/protected', function(req, res, next) {\n *       passport.authenticate('local', function(err, user, info, status) {\n *         if (err) { return next(err) }\n *         if (!user) { return res.redirect('/signin') }\n *         res.redirect('/account');\n *       })(req, res, next);\n *     });\n *\n * Note that if a callback is supplied, it becomes the application's\n * responsibility to log-in the user, establish a session, and otherwise perform\n * the desired operations.\n *\n * Examples:\n *\n *     passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' });\n *\n *     passport.authenticate('basic', { session: false });\n *\n *     passport.authenticate('twitter');\n *\n * @param {Strategy|String|Array} name\n * @param {Object} options\n * @param {Function} callback\n * @return {Function}\n * @api public\n */\nmodule.exports = function authenticate(passport, name, options, callback) {\n  if (typeof options == 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  var multi = true;\n\n  // Cast `name` to an array, allowing authentication to pass through a chain of\n  // strategies.  The first strategy to succeed, redirect, or error will halt\n  // the chain.  Authentication failures will proceed through each strategy in\n  // series, ultimately failing if all strategies fail.\n  //\n  // This is typically used on API endpoints to allow clients to authenticate\n  // using their preferred choice of Basic, Digest, token-based schemes, etc.\n  // It is not feasible to construct a chain of multiple strategies that involve\n  // redirection (for example both Facebook and Twitter), since the first one to\n  // redirect will halt the chain.\n  if (!Array.isArray(name)) {\n    name = [name];\n    multi = false;\n  }\n  return function authenticate(req, res, next) {\n    req.login = req.logIn = req.logIn || IncomingMessageExt.logIn;\n    req.logout = req.logOut = req.logOut || IncomingMessageExt.logOut;\n    req.isAuthenticated = req.isAuthenticated || IncomingMessageExt.isAuthenticated;\n    req.isUnauthenticated = req.isUnauthenticated || IncomingMessageExt.isUnauthenticated;\n    req._sessionManager = passport._sm;\n\n    // accumulator for failures from each strategy in the chain\n    var failures = [];\n    function allFailed() {\n      if (callback) {\n        if (!multi) {\n          return callback(null, false, failures[0].challenge, failures[0].status);\n        } else {\n          var challenges = failures.map(function (f) {\n            return f.challenge;\n          });\n          var statuses = failures.map(function (f) {\n            return f.status;\n          });\n          return callback(null, false, challenges, statuses);\n        }\n      }\n\n      // Strategies are ordered by priority.  For the purpose of flashing a\n      // message, the first failure will be displayed.\n      var failure = failures[0] || {},\n        challenge = failure.challenge || {},\n        msg;\n      if (options.failureFlash) {\n        var flash = options.failureFlash;\n        if (typeof flash == 'string') {\n          flash = {\n            type: 'error',\n            message: flash\n          };\n        }\n        flash.type = flash.type || 'error';\n        var type = flash.type || challenge.type || 'error';\n        msg = flash.message || challenge.message || challenge;\n        if (typeof msg == 'string') {\n          req.flash(type, msg);\n        }\n      }\n      if (options.failureMessage) {\n        msg = options.failureMessage;\n        if (typeof msg == 'boolean') {\n          msg = challenge.message || challenge;\n        }\n        if (typeof msg == 'string') {\n          req.session.messages = req.session.messages || [];\n          req.session.messages.push(msg);\n        }\n      }\n      if (options.failureRedirect) {\n        return res.redirect(options.failureRedirect);\n      }\n\n      // When failure handling is not delegated to the application, the default\n      // is to respond with 401 Unauthorized.  Note that the WWW-Authenticate\n      // header will be set according to the strategies in use (see\n      // actions#fail).  If multiple strategies failed, each of their challenges\n      // will be included in the response.\n      var rchallenge = [],\n        rstatus,\n        status;\n      for (var j = 0, len = failures.length; j < len; j++) {\n        failure = failures[j];\n        challenge = failure.challenge;\n        status = failure.status;\n        rstatus = rstatus || status;\n        if (typeof challenge == 'string') {\n          rchallenge.push(challenge);\n        }\n      }\n      res.statusCode = rstatus || 401;\n      if (res.statusCode == 401 && rchallenge.length) {\n        res.setHeader('WWW-Authenticate', rchallenge);\n      }\n      if (options.failWithError) {\n        return next(new AuthenticationError(http.STATUS_CODES[res.statusCode], rstatus));\n      }\n      res.end(http.STATUS_CODES[res.statusCode]);\n    }\n    (function attempt(i) {\n      var layer = name[i];\n      // If no more strategies exist in the chain, authentication has failed.\n      if (!layer) {\n        return allFailed();\n      }\n\n      // Get the strategy, which will be used as prototype from which to create\n      // a new instance.  Action functions will then be bound to the strategy\n      // within the context of the HTTP request/response pair.\n      var strategy, prototype;\n      if (typeof layer.authenticate == 'function') {\n        strategy = layer;\n      } else {\n        prototype = passport._strategy(layer);\n        if (!prototype) {\n          return next(new Error('Unknown authentication strategy \"' + layer + '\"'));\n        }\n        strategy = Object.create(prototype);\n      }\n\n      // ----- BEGIN STRATEGY AUGMENTATION -----\n      // Augment the new strategy instance with action functions.  These action\n      // functions are bound via closure the the request/response pair.  The end\n      // goal of the strategy is to invoke *one* of these action methods, in\n      // order to indicate successful or failed authentication, redirect to a\n      // third-party identity provider, etc.\n\n      /**\n       * Authenticate `user`, with optional `info`.\n       *\n       * Strategies should call this function to successfully authenticate a\n       * user.  `user` should be an object supplied by the application after it\n       * has been given an opportunity to verify credentials.  `info` is an\n       * optional argument containing additional user information.  This is\n       * useful for third-party authentication strategies to pass profile\n       * details.\n       *\n       * @param {Object} user\n       * @param {Object} info\n       * @api public\n       */\n      strategy.success = function (user, info) {\n        if (callback) {\n          return callback(null, user, info);\n        }\n        info = info || {};\n        var msg;\n        if (options.successFlash) {\n          var flash = options.successFlash;\n          if (typeof flash == 'string') {\n            flash = {\n              type: 'success',\n              message: flash\n            };\n          }\n          flash.type = flash.type || 'success';\n          var type = flash.type || info.type || 'success';\n          msg = flash.message || info.message || info;\n          if (typeof msg == 'string') {\n            req.flash(type, msg);\n          }\n        }\n        if (options.successMessage) {\n          msg = options.successMessage;\n          if (typeof msg == 'boolean') {\n            msg = info.message || info;\n          }\n          if (typeof msg == 'string') {\n            req.session.messages = req.session.messages || [];\n            req.session.messages.push(msg);\n          }\n        }\n        if (options.assignProperty) {\n          req[options.assignProperty] = user;\n          return next();\n        }\n        req.logIn(user, options, function (err) {\n          if (err) {\n            return next(err);\n          }\n          function complete() {\n            if (options.successReturnToOrRedirect) {\n              var url = options.successReturnToOrRedirect;\n              if (req.session && req.session.returnTo) {\n                url = req.session.returnTo;\n                delete req.session.returnTo;\n              }\n              return res.redirect(url);\n            }\n            if (options.successRedirect) {\n              return res.redirect(options.successRedirect);\n            }\n            next();\n          }\n          if (options.authInfo !== false) {\n            passport.transformAuthInfo(info, req, function (err, tinfo) {\n              if (err) {\n                return next(err);\n              }\n              req.authInfo = tinfo;\n              complete();\n            });\n          } else {\n            complete();\n          }\n        });\n      };\n\n      /**\n       * Fail authentication, with optional `challenge` and `status`, defaulting\n       * to 401.\n       *\n       * Strategies should call this function to fail an authentication attempt.\n       *\n       * @param {String} challenge\n       * @param {Number} status\n       * @api public\n       */\n      strategy.fail = function (challenge, status) {\n        if (typeof challenge == 'number') {\n          status = challenge;\n          challenge = undefined;\n        }\n\n        // push this failure into the accumulator and attempt authentication\n        // using the next strategy\n        failures.push({\n          challenge: challenge,\n          status: status\n        });\n        attempt(i + 1);\n      };\n\n      /**\n       * Redirect to `url` with optional `status`, defaulting to 302.\n       *\n       * Strategies should call this function to redirect the user (via their\n       * user agent) to a third-party website for authentication.\n       *\n       * @param {String} url\n       * @param {Number} status\n       * @api public\n       */\n      strategy.redirect = function (url, status) {\n        // NOTE: Do not use `res.redirect` from Express, because it can't decide\n        //       what it wants.\n        //\n        //       Express 2.x: res.redirect(url, status)\n        //       Express 3.x: res.redirect(status, url) -OR- res.redirect(url, status)\n        //         - as of 3.14.0, deprecated warnings are issued if res.redirect(url, status)\n        //           is used\n        //       Express 4.x: res.redirect(status, url)\n        //         - all versions (as of 4.8.7) continue to accept res.redirect(url, status)\n        //           but issue deprecated versions\n\n        res.statusCode = status || 302;\n        res.setHeader('Location', url);\n        res.setHeader('Content-Length', '0');\n        res.end();\n      };\n\n      /**\n       * Pass without making a success or fail decision.\n       *\n       * Under most circumstances, Strategies should not need to call this\n       * function.  It exists primarily to allow previous authentication state\n       * to be restored, for example from an HTTP session.\n       *\n       * @api public\n       */\n      strategy.pass = function () {\n        next();\n      };\n\n      /**\n       * Internal error while performing authentication.\n       *\n       * Strategies should call this function when an internal error occurs\n       * during the process of performing authentication; for example, if the\n       * user directory is not available.\n       *\n       * @param {Error} err\n       * @api public\n       */\n      strategy.error = function (err) {\n        if (callback) {\n          return callback(err);\n        }\n        next(err);\n      };\n\n      // ----- END STRATEGY AUGMENTATION -----\n\n      strategy.authenticate(req, options);\n    })(0); // attempt\n  };\n};","map":{"version":3,"names":["http","require","IncomingMessageExt","AuthenticationError","module","exports","authenticate","passport","name","options","callback","multi","Array","isArray","req","res","next","login","logIn","logout","logOut","isAuthenticated","isUnauthenticated","_sessionManager","_sm","failures","allFailed","challenge","status","challenges","map","f","statuses","failure","msg","failureFlash","flash","type","message","failureMessage","session","messages","push","failureRedirect","redirect","rchallenge","rstatus","j","len","length","statusCode","setHeader","failWithError","STATUS_CODES","end","attempt","i","layer","strategy","prototype","_strategy","Error","Object","create","success","user","info","successFlash","successMessage","assignProperty","err","complete","successReturnToOrRedirect","url","returnTo","successRedirect","authInfo","transformAuthInfo","tinfo","fail","undefined","pass","error"],"sources":["C:/Users/hoang/OneDrive/Documents/test/node_modules/passport/lib/middleware/authenticate.js"],"sourcesContent":["/**\n * Module dependencies.\n */\nvar http = require('http')\n  , IncomingMessageExt = require('../http/request')\n  , AuthenticationError = require('../errors/authenticationerror');\n\n\n/**\n * Authenticates requests.\n *\n * Applies the `name`ed strategy (or strategies) to the incoming request, in\n * order to authenticate the request.  If authentication is successful, the user\n * will be logged in and populated at `req.user` and a session will be\n * established by default.  If authentication fails, an unauthorized response\n * will be sent.\n *\n * Options:\n *   - `session`          Save login state in session, defaults to _true_\n *   - `successRedirect`  After successful login, redirect to given URL\n *   - `successMessage`   True to store success message in\n *                        req.session.messages, or a string to use as override\n *                        message for success.\n *   - `successFlash`     True to flash success messages or a string to use as a flash\n *                        message for success (overrides any from the strategy itself).\n *   - `failureRedirect`  After failed login, redirect to given URL\n *   - `failureMessage`   True to store failure message in\n *                        req.session.messages, or a string to use as override\n *                        message for failure.\n *   - `failureFlash`     True to flash failure messages or a string to use as a flash\n *                        message for failures (overrides any from the strategy itself).\n *   - `assignProperty`   Assign the object provided by the verify callback to given property\n *\n * An optional `callback` can be supplied to allow the application to override\n * the default manner in which authentication attempts are handled.  The\n * callback has the following signature, where `user` will be set to the\n * authenticated user on a successful authentication attempt, or `false`\n * otherwise.  An optional `info` argument will be passed, containing additional\n * details provided by the strategy's verify callback - this could be information about\n * a successful authentication or a challenge message for a failed authentication.\n * An optional `status` argument will be passed when authentication fails - this could\n * be a HTTP response code for a remote authentication failure or similar.\n *\n *     app.get('/protected', function(req, res, next) {\n *       passport.authenticate('local', function(err, user, info, status) {\n *         if (err) { return next(err) }\n *         if (!user) { return res.redirect('/signin') }\n *         res.redirect('/account');\n *       })(req, res, next);\n *     });\n *\n * Note that if a callback is supplied, it becomes the application's\n * responsibility to log-in the user, establish a session, and otherwise perform\n * the desired operations.\n *\n * Examples:\n *\n *     passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' });\n *\n *     passport.authenticate('basic', { session: false });\n *\n *     passport.authenticate('twitter');\n *\n * @param {Strategy|String|Array} name\n * @param {Object} options\n * @param {Function} callback\n * @return {Function}\n * @api public\n */\nmodule.exports = function authenticate(passport, name, options, callback) {\n  if (typeof options == 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  \n  var multi = true;\n  \n  // Cast `name` to an array, allowing authentication to pass through a chain of\n  // strategies.  The first strategy to succeed, redirect, or error will halt\n  // the chain.  Authentication failures will proceed through each strategy in\n  // series, ultimately failing if all strategies fail.\n  //\n  // This is typically used on API endpoints to allow clients to authenticate\n  // using their preferred choice of Basic, Digest, token-based schemes, etc.\n  // It is not feasible to construct a chain of multiple strategies that involve\n  // redirection (for example both Facebook and Twitter), since the first one to\n  // redirect will halt the chain.\n  if (!Array.isArray(name)) {\n    name = [ name ];\n    multi = false;\n  }\n  \n  return function authenticate(req, res, next) {\n    req.login =\n    req.logIn = req.logIn || IncomingMessageExt.logIn;\n    req.logout =\n    req.logOut = req.logOut || IncomingMessageExt.logOut;\n    req.isAuthenticated = req.isAuthenticated || IncomingMessageExt.isAuthenticated;\n    req.isUnauthenticated = req.isUnauthenticated || IncomingMessageExt.isUnauthenticated;\n    \n    req._sessionManager = passport._sm;\n    \n    // accumulator for failures from each strategy in the chain\n    var failures = [];\n    \n    function allFailed() {\n      if (callback) {\n        if (!multi) {\n          return callback(null, false, failures[0].challenge, failures[0].status);\n        } else {\n          var challenges = failures.map(function(f) { return f.challenge; });\n          var statuses = failures.map(function(f) { return f.status; });\n          return callback(null, false, challenges, statuses);\n        }\n      }\n      \n      // Strategies are ordered by priority.  For the purpose of flashing a\n      // message, the first failure will be displayed.\n      var failure = failures[0] || {}\n        , challenge = failure.challenge || {}\n        , msg;\n    \n      if (options.failureFlash) {\n        var flash = options.failureFlash;\n        if (typeof flash == 'string') {\n          flash = { type: 'error', message: flash };\n        }\n        flash.type = flash.type || 'error';\n      \n        var type = flash.type || challenge.type || 'error';\n        msg = flash.message || challenge.message || challenge;\n        if (typeof msg == 'string') {\n          req.flash(type, msg);\n        }\n      }\n      if (options.failureMessage) {\n        msg = options.failureMessage;\n        if (typeof msg == 'boolean') {\n          msg = challenge.message || challenge;\n        }\n        if (typeof msg == 'string') {\n          req.session.messages = req.session.messages || [];\n          req.session.messages.push(msg);\n        }\n      }\n      if (options.failureRedirect) {\n        return res.redirect(options.failureRedirect);\n      }\n    \n      // When failure handling is not delegated to the application, the default\n      // is to respond with 401 Unauthorized.  Note that the WWW-Authenticate\n      // header will be set according to the strategies in use (see\n      // actions#fail).  If multiple strategies failed, each of their challenges\n      // will be included in the response.\n      var rchallenge = []\n        , rstatus, status;\n      \n      for (var j = 0, len = failures.length; j < len; j++) {\n        failure = failures[j];\n        challenge = failure.challenge;\n        status = failure.status;\n          \n        rstatus = rstatus || status;\n        if (typeof challenge == 'string') {\n          rchallenge.push(challenge);\n        }\n      }\n    \n      res.statusCode = rstatus || 401;\n      if (res.statusCode == 401 && rchallenge.length) {\n        res.setHeader('WWW-Authenticate', rchallenge);\n      }\n      if (options.failWithError) {\n        return next(new AuthenticationError(http.STATUS_CODES[res.statusCode], rstatus));\n      }\n      res.end(http.STATUS_CODES[res.statusCode]);\n    }\n    \n    (function attempt(i) {\n      var layer = name[i];\n      // If no more strategies exist in the chain, authentication has failed.\n      if (!layer) { return allFailed(); }\n    \n      // Get the strategy, which will be used as prototype from which to create\n      // a new instance.  Action functions will then be bound to the strategy\n      // within the context of the HTTP request/response pair.\n      var strategy, prototype;\n      if (typeof layer.authenticate == 'function') {\n        strategy = layer;\n      } else {\n        prototype = passport._strategy(layer);\n        if (!prototype) { return next(new Error('Unknown authentication strategy \"' + layer + '\"')); }\n        \n        strategy = Object.create(prototype);\n      }\n      \n      \n      // ----- BEGIN STRATEGY AUGMENTATION -----\n      // Augment the new strategy instance with action functions.  These action\n      // functions are bound via closure the the request/response pair.  The end\n      // goal of the strategy is to invoke *one* of these action methods, in\n      // order to indicate successful or failed authentication, redirect to a\n      // third-party identity provider, etc.\n      \n      /**\n       * Authenticate `user`, with optional `info`.\n       *\n       * Strategies should call this function to successfully authenticate a\n       * user.  `user` should be an object supplied by the application after it\n       * has been given an opportunity to verify credentials.  `info` is an\n       * optional argument containing additional user information.  This is\n       * useful for third-party authentication strategies to pass profile\n       * details.\n       *\n       * @param {Object} user\n       * @param {Object} info\n       * @api public\n       */\n      strategy.success = function(user, info) {\n        if (callback) {\n          return callback(null, user, info);\n        }\n      \n        info = info || {};\n        var msg;\n      \n        if (options.successFlash) {\n          var flash = options.successFlash;\n          if (typeof flash == 'string') {\n            flash = { type: 'success', message: flash };\n          }\n          flash.type = flash.type || 'success';\n        \n          var type = flash.type || info.type || 'success';\n          msg = flash.message || info.message || info;\n          if (typeof msg == 'string') {\n            req.flash(type, msg);\n          }\n        }\n        if (options.successMessage) {\n          msg = options.successMessage;\n          if (typeof msg == 'boolean') {\n            msg = info.message || info;\n          }\n          if (typeof msg == 'string') {\n            req.session.messages = req.session.messages || [];\n            req.session.messages.push(msg);\n          }\n        }\n        if (options.assignProperty) {\n          req[options.assignProperty] = user;\n          return next();\n        }\n      \n        req.logIn(user, options, function(err) {\n          if (err) { return next(err); }\n          \n          function complete() {\n            if (options.successReturnToOrRedirect) {\n              var url = options.successReturnToOrRedirect;\n              if (req.session && req.session.returnTo) {\n                url = req.session.returnTo;\n                delete req.session.returnTo;\n              }\n              return res.redirect(url);\n            }\n            if (options.successRedirect) {\n              return res.redirect(options.successRedirect);\n            }\n            next();\n          }\n          \n          if (options.authInfo !== false) {\n            passport.transformAuthInfo(info, req, function(err, tinfo) {\n              if (err) { return next(err); }\n              req.authInfo = tinfo;\n              complete();\n            });\n          } else {\n            complete();\n          }\n        });\n      };\n      \n      /**\n       * Fail authentication, with optional `challenge` and `status`, defaulting\n       * to 401.\n       *\n       * Strategies should call this function to fail an authentication attempt.\n       *\n       * @param {String} challenge\n       * @param {Number} status\n       * @api public\n       */\n      strategy.fail = function(challenge, status) {\n        if (typeof challenge == 'number') {\n          status = challenge;\n          challenge = undefined;\n        }\n        \n        // push this failure into the accumulator and attempt authentication\n        // using the next strategy\n        failures.push({ challenge: challenge, status: status });\n        attempt(i + 1);\n      };\n      \n      /**\n       * Redirect to `url` with optional `status`, defaulting to 302.\n       *\n       * Strategies should call this function to redirect the user (via their\n       * user agent) to a third-party website for authentication.\n       *\n       * @param {String} url\n       * @param {Number} status\n       * @api public\n       */\n      strategy.redirect = function(url, status) {\n        // NOTE: Do not use `res.redirect` from Express, because it can't decide\n        //       what it wants.\n        //\n        //       Express 2.x: res.redirect(url, status)\n        //       Express 3.x: res.redirect(status, url) -OR- res.redirect(url, status)\n        //         - as of 3.14.0, deprecated warnings are issued if res.redirect(url, status)\n        //           is used\n        //       Express 4.x: res.redirect(status, url)\n        //         - all versions (as of 4.8.7) continue to accept res.redirect(url, status)\n        //           but issue deprecated versions\n        \n        res.statusCode = status || 302;\n        res.setHeader('Location', url);\n        res.setHeader('Content-Length', '0');\n        res.end();\n      };\n      \n      /**\n       * Pass without making a success or fail decision.\n       *\n       * Under most circumstances, Strategies should not need to call this\n       * function.  It exists primarily to allow previous authentication state\n       * to be restored, for example from an HTTP session.\n       *\n       * @api public\n       */\n      strategy.pass = function() {\n        next();\n      };\n      \n      /**\n       * Internal error while performing authentication.\n       *\n       * Strategies should call this function when an internal error occurs\n       * during the process of performing authentication; for example, if the\n       * user directory is not available.\n       *\n       * @param {Error} err\n       * @api public\n       */\n      strategy.error = function(err) {\n        if (callback) {\n          return callback(err);\n        }\n        \n        next(err);\n      };\n      \n      // ----- END STRATEGY AUGMENTATION -----\n    \n      strategy.authenticate(req, options);\n    })(0); // attempt\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}